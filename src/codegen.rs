use crate::ast::*;
use std::collections::HashMap;

pub struct CodeGen {
    output: String,
    reg_counter: usize,
    label_counter: usize,
    vars: Vec<HashMap<String, String>>,
}

impl CodeGen {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            reg_counter: 0,
            label_counter: 0,
            vars: Vec::new(),
        }
    }

    fn new_reg(&mut self) -> String {
        let r = format!("%t{}", self.reg_counter);
        self.reg_counter += 1;
        r
    }

    fn new_label(&mut self, prefix: &str) -> String {
        let l = format!("{}{}", prefix, self.label_counter);
        self.label_counter += 1;
        l
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn inst(&mut self, s: &str) {
        self.output.push_str("  ");
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn push_scope(&mut self) {
        self.vars.push(HashMap::new());
    }

    fn pop_scope(&mut self) {
        self.vars.pop();
    }

    fn define_var(&mut self, name: &str, alloca_reg: &str) {
        if let Some(scope) = self.vars.last_mut() {
            scope.insert(name.to_string(), alloca_reg.to_string());
        }
    }

    fn lookup_var(&self, name: &str) -> String {
        for scope in self.vars.iter().rev() {
            if let Some(reg) = scope.get(name) {
                return reg.clone();
            }
        }
        panic!("codegen: undefined variable: {}", name);
    }

    fn mangle(name: &str) -> String {
        if name == "main" {
            "main".to_string()
        } else {
            format!("cz_{}", name)
        }
    }

    pub fn generate(&mut self, program: &Program) -> String {
        self.emit("; Generated by czc");
        self.emit("");
        self.emit("@.fmt_i32 = private unnamed_addr constant [4 x i8] c\"%d\\0A\\00\"");
        self.emit("@.div_zero_msg = private unnamed_addr constant [33 x i8] c\"runtime error: division by zero\\0A\\00\"");
        self.emit("");
        self.emit("declare i32 @printf(ptr, ...)");
        self.emit("declare void @exit(i32)");
        self.emit("");

        // print_i32 builtin
        self.emit("define i32 @cz_print_i32(i32 %x) {");
        self.emit("entry:");
        self.inst("call i32 (ptr, ...) @printf(ptr @.fmt_i32, i32 %x)");
        self.inst("ret i32 0");
        self.emit("}");
        self.emit("");

        for func in &program.functions {
            self.emit_function(func);
            self.emit("");
        }

        self.output.clone()
    }

    fn emit_function(&mut self, func: &FunctionDef) {
        self.reg_counter = 0;
        self.label_counter = 0;
        self.vars.clear();

        let c_name = Self::mangle(&func.name);
        let params: Vec<String> = func
            .params
            .iter()
            .map(|p| format!("i32 %param_{}", p.name))
            .collect();

        self.emit(&format!("define i32 @{}({}) {{", c_name, params.join(", ")));
        self.emit("entry:");

        self.push_scope();

        for param in &func.params {
            let addr = self.new_reg();
            self.inst(&format!("{} = alloca i32", addr));
            self.inst(&format!("store i32 %param_{}, ptr {}", param.name, addr));
            self.define_var(&param.name, &addr);
        }

        self.emit_block_as_return(&func.body);
        self.pop_scope();
        self.emit("}");
    }

    fn emit_block_as_return(&mut self, block: &Block) {
        for stmt in &block.stmts {
            self.emit_stmt(stmt);
        }
        if let Some(expr) = &block.expr {
            let val = self.emit_expr(expr);
            self.inst(&format!("ret i32 {}", val));
        }
    }

    fn emit_block_value(&mut self, block: &Block) -> String {
        self.push_scope();
        for stmt in &block.stmts {
            self.emit_stmt(stmt);
        }
        let val = if let Some(expr) = &block.expr {
            self.emit_expr(expr)
        } else {
            "0".to_string()
        };
        self.pop_scope();
        val
    }

    fn emit_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let { name, init, .. } => {
                let val = self.emit_expr(init);
                let addr = self.new_reg();
                self.inst(&format!("{} = alloca i32", addr));
                self.inst(&format!("store i32 {}, ptr {}", val, addr));
                self.define_var(name, &addr);
            }
            Stmt::While { condition, body } => {
                let cond_label = self.new_label("while.cond");
                let body_label = self.new_label("while.body");
                let end_label = self.new_label("while.end");

                self.inst(&format!("br label %{}", cond_label));
                self.emit(&format!("{}:", cond_label));

                let cond_val = self.emit_expr(condition);
                let cond_bool = self.new_reg();
                self.inst(&format!("{} = icmp ne i32 {}, 0", cond_bool, cond_val));
                self.inst(&format!(
                    "br i1 {}, label %{}, label %{}",
                    cond_bool, body_label, end_label
                ));

                self.emit(&format!("{}:", body_label));
                self.push_scope();
                for s in &body.stmts {
                    self.emit_stmt(s);
                }
                self.pop_scope();
                self.inst(&format!("br label %{}", cond_label));

                self.emit(&format!("{}:", end_label));
            }
            Stmt::Return { value, .. } => {
                let val = self.emit_expr(value);
                self.inst(&format!("ret i32 {}", val));
                // Need a new basic block for any code after return
                let after = self.new_label("after.ret");
                self.emit(&format!("{}:", after));
            }
            Stmt::Expr(expr) => {
                self.emit_expr(expr);
            }
        }
    }

    fn emit_expr(&mut self, expr: &Expr) -> String {
        match expr {
            Expr::IntegerLiteral(val) => format!("{}", val),
            Expr::BoolLiteral(b) => {
                if *b { "1".to_string() } else { "0".to_string() }
            }
            Expr::Identifier(name, _) => {
                let addr = self.lookup_var(name);
                let reg = self.new_reg();
                self.inst(&format!("{} = load i32, ptr {}", reg, addr));
                reg
            }
            Expr::BinaryOp { op, left, right } => match op {
                BinOp::And => self.emit_and(left, right),
                BinOp::Or => self.emit_or(left, right),
                BinOp::Div | BinOp::Mod => self.emit_div_mod(left, right, *op),
                _ => {
                    let lval = self.emit_expr(left);
                    let rval = self.emit_expr(right);
                    self.emit_binop(*op, &lval, &rval)
                }
            },
            Expr::UnaryOp { op, operand } => {
                let val = self.emit_expr(operand);
                match op {
                    UnaryOp::Neg => {
                        let reg = self.new_reg();
                        self.inst(&format!("{} = sub i32 0, {}", reg, val));
                        reg
                    }
                    UnaryOp::Not => {
                        let cmp = self.new_reg();
                        self.inst(&format!("{} = icmp eq i32 {}, 0", cmp, val));
                        let reg = self.new_reg();
                        self.inst(&format!("{} = zext i1 {} to i32", reg, cmp));
                        reg
                    }
                }
            }
            Expr::Call { name, args, .. } => {
                let arg_vals: Vec<String> =
                    args.iter().map(|a| self.emit_expr(a)).collect();
                let c_name = Self::mangle(name);
                let arg_list: Vec<String> =
                    arg_vals.iter().map(|v| format!("i32 {}", v)).collect();
                let reg = self.new_reg();
                self.inst(&format!(
                    "{} = call i32 @{}({})",
                    reg, c_name, arg_list.join(", ")
                ));
                reg
            }
            Expr::Assign { name, value, .. } => {
                let val = self.emit_expr(value);
                let addr = self.lookup_var(name);
                self.inst(&format!("store i32 {}, ptr {}", val, addr));
                val
            }
            Expr::If {
                condition,
                then_block,
                else_block,
            } => match else_block {
                Some(else_clause) => {
                    self.emit_if_expr(condition, then_block, else_clause)
                }
                None => self.emit_if_stmt(condition, then_block),
            },
            Expr::Block(block) => self.emit_block_value(block),
        }
    }

    fn emit_binop(&mut self, op: BinOp, lval: &str, rval: &str) -> String {
        let reg = self.new_reg();
        match op {
            BinOp::Add => {
                self.inst(&format!("{} = add i32 {}, {}", reg, lval, rval));
            }
            BinOp::Sub => {
                self.inst(&format!("{} = sub i32 {}, {}", reg, lval, rval));
            }
            BinOp::Mul => {
                self.inst(&format!("{} = mul i32 {}, {}", reg, lval, rval));
            }
            BinOp::Eq | BinOp::NotEq | BinOp::Lt | BinOp::Gt
            | BinOp::LtEq | BinOp::GtEq => {
                let cmp_kind = match op {
                    BinOp::Eq => "eq",
                    BinOp::NotEq => "ne",
                    BinOp::Lt => "slt",
                    BinOp::Gt => "sgt",
                    BinOp::LtEq => "sle",
                    BinOp::GtEq => "sge",
                    _ => unreachable!(),
                };
                let cmp = self.new_reg();
                self.inst(&format!("{} = icmp {} i32 {}, {}", cmp, cmp_kind, lval, rval));
                self.inst(&format!("{} = zext i1 {} to i32", reg, cmp));
            }
            _ => unreachable!(),
        }
        reg
    }

    fn emit_and(&mut self, left: &Expr, right: &Expr) -> String {
        let result_addr = self.new_reg();
        self.inst(&format!("{} = alloca i32", result_addr));

        let lval = self.emit_expr(left);
        let lcond = self.new_reg();
        self.inst(&format!("{} = icmp ne i32 {}, 0", lcond, lval));

        let rhs_label = self.new_label("and.rhs");
        let false_label = self.new_label("and.false");
        let merge_label = self.new_label("and.merge");

        self.inst(&format!(
            "br i1 {}, label %{}, label %{}",
            lcond, rhs_label, false_label
        ));

        self.emit(&format!("{}:", rhs_label));
        let rval = self.emit_expr(right);
        let rcond = self.new_reg();
        self.inst(&format!("{} = icmp ne i32 {}, 0", rcond, rval));
        let rext = self.new_reg();
        self.inst(&format!("{} = zext i1 {} to i32", rext, rcond));
        self.inst(&format!("store i32 {}, ptr {}", rext, result_addr));
        self.inst(&format!("br label %{}", merge_label));

        self.emit(&format!("{}:", false_label));
        self.inst(&format!("store i32 0, ptr {}", result_addr));
        self.inst(&format!("br label %{}", merge_label));

        self.emit(&format!("{}:", merge_label));
        let result = self.new_reg();
        self.inst(&format!("{} = load i32, ptr {}", result, result_addr));
        result
    }

    fn emit_or(&mut self, left: &Expr, right: &Expr) -> String {
        let result_addr = self.new_reg();
        self.inst(&format!("{} = alloca i32", result_addr));

        let lval = self.emit_expr(left);
        let lcond = self.new_reg();
        self.inst(&format!("{} = icmp ne i32 {}, 0", lcond, lval));

        let true_label = self.new_label("or.true");
        let rhs_label = self.new_label("or.rhs");
        let merge_label = self.new_label("or.merge");

        self.inst(&format!(
            "br i1 {}, label %{}, label %{}",
            lcond, true_label, rhs_label
        ));

        self.emit(&format!("{}:", true_label));
        self.inst(&format!("store i32 {}, ptr {}", lval, result_addr));
        self.inst(&format!("br label %{}", merge_label));

        self.emit(&format!("{}:", rhs_label));
        let rval = self.emit_expr(right);
        self.inst(&format!("store i32 {}, ptr {}", rval, result_addr));
        self.inst(&format!("br label %{}", merge_label));

        self.emit(&format!("{}:", merge_label));
        let result = self.new_reg();
        self.inst(&format!("{} = load i32, ptr {}", result, result_addr));
        result
    }

    fn emit_div_mod(&mut self, left: &Expr, right: &Expr, op: BinOp) -> String {
        let lval = self.emit_expr(left);
        let rval = self.emit_expr(right);

        let is_zero = self.new_reg();
        self.inst(&format!("{} = icmp eq i32 {}, 0", is_zero, rval));

        let trap_label = self.new_label("div.trap");
        let ok_label = self.new_label("div.ok");

        self.inst(&format!(
            "br i1 {}, label %{}, label %{}",
            is_zero, trap_label, ok_label
        ));

        self.emit(&format!("{}:", trap_label));
        self.inst("call i32 (ptr, ...) @printf(ptr @.div_zero_msg)");
        self.inst("call void @exit(i32 1)");
        self.inst("unreachable");

        self.emit(&format!("{}:", ok_label));
        let reg = self.new_reg();
        let ir_op = match op {
            BinOp::Div => "sdiv",
            BinOp::Mod => "srem",
            _ => unreachable!(),
        };
        self.inst(&format!("{} = {} i32 {}, {}", reg, ir_op, lval, rval));
        reg
    }

    fn emit_if_expr(
        &mut self,
        condition: &Expr,
        then_block: &Block,
        else_clause: &ElseClause,
    ) -> String {
        let result_addr = self.new_reg();
        self.inst(&format!("{} = alloca i32", result_addr));

        let cond_val = self.emit_expr(condition);
        let cond_bool = self.new_reg();
        self.inst(&format!("{} = icmp ne i32 {}, 0", cond_bool, cond_val));

        let then_label = self.new_label("if.then");
        let else_label = self.new_label("if.else");
        let merge_label = self.new_label("if.merge");

        self.inst(&format!(
            "br i1 {}, label %{}, label %{}",
            cond_bool, then_label, else_label
        ));

        self.emit(&format!("{}:", then_label));
        let then_val = self.emit_block_value(then_block);
        self.inst(&format!("store i32 {}, ptr {}", then_val, result_addr));
        self.inst(&format!("br label %{}", merge_label));

        self.emit(&format!("{}:", else_label));
        let else_val = match else_clause {
            ElseClause::ElseBlock(block) => self.emit_block_value(block),
            ElseClause::ElseIf(if_expr) => self.emit_expr(if_expr),
        };
        self.inst(&format!("store i32 {}, ptr {}", else_val, result_addr));
        self.inst(&format!("br label %{}", merge_label));

        self.emit(&format!("{}:", merge_label));
        let result = self.new_reg();
        self.inst(&format!("{} = load i32, ptr {}", result, result_addr));
        result
    }

    fn emit_if_stmt(&mut self, condition: &Expr, then_block: &Block) -> String {
        let cond_val = self.emit_expr(condition);
        let cond_bool = self.new_reg();
        self.inst(&format!("{} = icmp ne i32 {}, 0", cond_bool, cond_val));

        let then_label = self.new_label("if.then");
        let end_label = self.new_label("if.end");

        self.inst(&format!(
            "br i1 {}, label %{}, label %{}",
            cond_bool, then_label, end_label
        ));

        self.emit(&format!("{}:", then_label));
        self.push_scope();
        for s in &then_block.stmts {
            self.emit_stmt(s);
        }
        if let Some(tail) = &then_block.expr {
            self.emit_expr(tail);
        }
        self.pop_scope();
        self.inst(&format!("br label %{}", end_label));

        self.emit(&format!("{}:", end_label));
        "0".to_string()
    }
}
