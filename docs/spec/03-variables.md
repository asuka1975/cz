# 03 - 変数と束縛

## 概要

Cz の変数は `let` キーワードで宣言する。変数のミュータビリティは明示的に管理され、デフォルトではイミュータブル (不変) である。

## 構文

```bnf
let_statement     = "let" ["mut"] identifier ":" type "=" expression ";"
assignment        = identifier "=" expression ";"
```

## 意味論

### 変数宣言

- `let` で宣言された変数はイミュータブルであり、再代入できない
- `let mut` で宣言された変数はミュータブルであり、再代入可能
- 型注釈は MS1 では必須
- 初期化式は必須 (未初期化変数は許可しない)

### 再代入

- `let mut` で宣言された変数のみ再代入可能
- `let` で宣言された変数への再代入はコンパイルエラー
- 再代入は `identifier = expression;` の形式で行う

### シャドーイング

- 同一スコープ内で同名の変数を `let` で再宣言できる (シャドーイング)
- シャドーイングにより、新しい束縛が作成され、以前の束縛は隠される

### スコープ

- 変数のスコープは宣言を含むブロック (`{` ... `}`) に限定される
- 内側のブロックから外側のブロックの変数を参照できる
- ブロックを抜けると、そのブロックで宣言された変数は破棄される

## 例

```cz
fn main() -> i32 {
    // イミュータブル変数
    let x: i32 = 10;
    // x = 20;  // compile-error: イミュータブル変数への再代入

    // ミュータブル変数
    let mut y: i32 = 10;
    y = 20;  // OK

    // シャドーイング
    let x: i32 = x + 1;  // OK: 新しい束縛を作成

    // スコープ
    let a: i32 = 1;
    {
        let b: i32 = 2;
        let c: i32 = a + b;  // OK: 外側の変数を参照
    }
    // b はここでは使えない (compile-error)

    0
}
```

## 制約・制限

- 型注釈は MS1 では省略不可 (将来のマイルストーンで型推論を導入予定)
- 初期化なしの変数宣言は許可しない
- グローバル変数は MS1 ではサポートしない
