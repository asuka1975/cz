# 03 - 変数と束縛

## 概要

Cz の変数は `let` キーワードで宣言する。変数のミュータビリティは明示的に管理され、デフォルトではイミュータブル (不変) である。

## 構文

```bnf
let_statement     = "let" ["mut"] identifier [":" type] "=" expression ";"
assignment        = identifier "=" expression ";"
```

## 意味論

### 変数宣言

- `let` で宣言された変数はイミュータブルであり、再代入できない
- `let mut` で宣言された変数はミュータブルであり、再代入可能
- 初期化式は必須 (未初期化変数は許可しない)

### 型注釈と型推論 (MS2)

- 型注釈は省略可能 (MS1 では必須だった)
- 型注釈が省略された場合、初期化式の型から推論する
- 整数リテラル (サフィックスなし) は `i32` に推論される
- 浮動小数点リテラル (サフィックスなし) は `f64` に推論される
- `true` / `false` は `bool` に推論される
- 構造体コンストラクタ、列挙型コンストラクタ、タプルはそれぞれの型に推論される
- 関数呼び出しの戻り値型から推論される
- 型注釈がある場合でも、初期化式の型と型注釈が一致しなければコンパイルエラー

```cz
let x = 42;              // i32 に推論
let y = 3.14;            // f64 に推論
let flag = true;         // bool に推論
let z: i64 = 42;         // 型注釈あり: i64 だがリテラル 42 は i32 → コンパイルエラー
let z: i64 = 42i64;      // OK: i64 リテラル
```

### 再代入

- `let mut` で宣言された変数のみ再代入可能
- `let` で宣言された変数への再代入はコンパイルエラー
- 再代入は `identifier = expression;` の形式で行う
- 再代入する値の型は変数の型と一致しなければならない

### シャドーイングの禁止

- 同一スコープ内で同名の変数を `let` で再宣言することはできない (コンパイルエラー)
- 異なるスコープ (内側のブロック) では同名の変数を宣言できる (内側のスコープで外側の変数が隠される)

### スコープ

- 変数のスコープは宣言を含むブロック (`{` ... `}`) に限定される
- 内側のブロックから外側のブロックの変数を参照できる
- ブロックを抜けると、そのブロックで宣言された変数は破棄される

## 例

```cz
fn main() -> i32 {
    // 型推論 (MS2)
    let x = 10;           // i32 に推論
    let pi = 3.14;        // f64 に推論
    let flag = true;      // bool に推論
    let big = 100i64;     // i64 (サフィックスで明示)

    // 型注釈あり
    let y: i32 = 20;

    // ミュータブル変数
    let mut count = 0;
    count = count + 1;

    // シャドーイング禁止
    // let x = x + 1;  // compile-error: 同一スコープで同名の変数を再宣言

    // スコープ
    let a = 1;
    {
        let b = 2;
        let c = a + b;  // OK: 外側の変数を参照
    }
    // b はここでは使えない (compile-error)

    0
}
```

## 制約・制限

- 初期化なしの変数宣言は許可しない
- グローバル変数はサポートしない
- 型推論は初期化式のみから行う (使用箇所からの逆推論はしない)
